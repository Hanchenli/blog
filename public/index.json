[{"content":"Context Engineering \u0026amp; Reuse Pattern Under the Hood of Claude Code Over the last few months, Claude Code has quietly become one of the most interesting \u0026amp; widely-adopted real-world agentic systems available to normal developers.\nUnlike cloud-only agents whose internals remain hidden behind API gateways like Perplexity, Devin, or Manus, nor as fully open source agents like Mini SWE Agent or Terminus 2 where you can deploy locally with source code, Claude Code runs partially locally — it has a open-sourced client repo running on the local machine, which gives us a rare opportunity: to inject the traffic it sends and reverse engineering to see every single LLM call, every intermediate tool invocation, every tiny decision the agent makes.\nRecently, we ran a tiny one-shot experiment (one random task from the SWE-bench_Verified dataset) with Claude Code and captured everything into a raw log file with only LLM input\u0026amp;output: claude_code_trace.jsonl. If you paste this trace into the visualizer, you can see the trace details.\nKey metrics:\n92 LLM calls (#1-#92) ~2M input tokens consumed 13 minutes total duration 92% prefix reuse rate The goal was simple:\nIf you give Claude Code one small task, what exactly happens behind the scenes?\nWhich LLM calls get made? In what order?\nWhere does context get reused? And how much of the prompt is stable prefix(seen) vs incremental content(new)?\nThis is our walk-through of that trace.\n1. What “Actually Happens” When Claude Code Runs a Simple Task Claude Code feels straightforward as a product — you type a request in your editor, it edits files or runs some bash commands. But under the hood, even a simple one-step request decomposes into a surprisingly structured internal loop.\nWe randomly select one task (#80) from the SWE-bench_Verified dataset. The problem setup is to fix an issue in the django/django repo from commit 2e0f04507b17362239ba49830d26fec504d46978.\nProblem statement:\n\u0026ldquo;JSONField are not properly displayed in admin when they are readonly.\nDescription: JSONField values are displayed as dict when readonly in the admin. For example, {\u0026quot;foo\u0026quot;: \u0026quot;bar\u0026quot;} would be displayed as {'foo': 'bar'}, which is not valid JSON.\nI believe the fix would be to add a special case in django.contrib.admin.utils.display_for_field to call the prepare_value of the JSONField (not calling json.dumps directly to take care of the InvalidJSONInput case).\u0026rdquo;\nAnd this is exactly the prompt that Claude Code received.\nSurprisingly, before any fancy reasoning, Claude Code ran a couple of \u0026ldquo;warm-up\u0026rdquo; steps (trace ID #2, #3, #4) before the actual task. Warm-up steps do nothing but input the prompt for:\nTool list (#2) Explore subagent (#3) Plan subagent (#4) Warm-up steps are used for caching purposes—later when those tools and subagents are called, the cache will be hit, resulting in faster response time. The summarization agent (#1) and new topic agent (#5) are used for summarizing the context and generating a new title for display—just as the ChatGPT sidebar works.\nThe main agent (#6) comes with a huge system prompt, including git history, status, tool list, etc. The 18 tools in the tool list not only have the ability to use normal tool calls like Bash, Grep, Read, WebFetch, AskUserQuestion, etc., but also the ability to invoke and delegate certain tasks to subagents like:\nExplore subagent (#7) Plan subagent (#46) These subagents will invoke tool calls from their own tool lists.\nImmediately after the main agent (#6), it invokes the Explore (also called file search agent) subagent (#7), which will invoke tool calls from its tool list to explore the codebase. It starts with a different system prompt where its main goal is to explore the codebase:\nYou are Claude Code, Anthropic\u0026rsquo;s official CLI for Claude. You are a file search specialist for Claude Code, Anthropic\u0026rsquo;s official CLI for Claude. You excel at thoroughly navigating and exploring codebases.\nInterestingly, the Explore subagent (#7) is not the only subagent that Claude Code can invoke. Instead, it invokes 3 Explore subagents in parallel to explore the codebase, each with a different goal:\nExplore JSONField implementation (lifespan: #7-#26) Explore admin display_for_field (lifespan: #8-#37) Explore readonly field rendering (lifespan: #9-#45) The context of the main agent (#6) is not carried to the subagents, which is beneficial for the subagents to have a fresh start. Each Explore subagent can invoke 1-3 tools in parallel, where the tools are from the tool list of the Explore subagent—a subset (10/18) of the main agent\u0026rsquo;s tool list.\nThe ReAct mechanism is used here: the Explore subagent will invoke a tool call, then based on the tool output, it will observe and invoke another tool call to explore the codebase further until it deems it has explored enough.\nFinally, after the slowest Explore subagent finishes its exploration at step #45, at step #46, the main agent appends the findings (summarizations) from all 3 Explore subagents to the context, and then invokes the Plan subagent (#47) to plan the fix.\nSimilar to the Explore Agent, the Plan Agent (#47) also has a different system prompt, where its main goal is to plan the fix:\nYou are Claude Code, Anthropic\u0026rsquo;s official CLI for Claude. You are a software architect and planning specialist for Claude Code. Your role is to explore the codebase and design implementation plans.\nThe Plan Agent did not carry all the context from the main agent nor the Explore subagents, which is beneficial for the Plan Agent to have a fresh start. Instead, it only contains the summarization of the Explore subagents\u0026rsquo; findings. The toolbox is a subset (10/18) of the main agent\u0026rsquo;s tool list. The goal for the Plan Agent is to design an implementation plan that:\nPlease design an implementation plan that:\nIdentifies the exact changes needed to display_for_field Considers whether we need to instantiate a form field from the model field or if there\u0026rsquo;s a better approach Identifies any edge cases or potential issues Recommends the best approach given Django\u0026rsquo;s architecture Similarly, the Plan Agent also follows the ReAct pattern and loops through tool calling from #47 to #72, where the context accumulates from 11,552 tokens to 38,819 tokens. After having a good plan (see details in #72), the Plan Agent will return to the main agent (#73) with the plan.\nThe main agent will then invoke a series of tool calls to:\nReview the plan (#73) Ask user for clarification (#74) Write the plan into a markdown file (#75) Finally, the main agent will exit the plan mode (#76) and enter the execute mode (#77) to execute the plan after interactively asking the user for plan approval (#76-#77).\nThe execution phase (#77-#91) still follows the ReAct pattern. The main agent will use the plan markdown file as a todo list:\nAdd json import to utils.py Add JSONField handling to display_for_field() Add tests to test_admin_utils.py Run the tests to verify After executing some tool calls to read or edit files, it will cross out the todo items in the plan markdown file. Once all the todo items are crossed out, the main agent will end with a conclusion message (#92).\nDuring this phase, there are some other subagents being invoked—e.g., the Extract Bash Command subagent (#93), where there\u0026rsquo;s only a one-shot prompt template for the subagent to extract the bash command in order to not run dangerous commands like rm without user confirmation by accident.\nAnd this is the whole diagram of the claude code trace:\n2. The Secret Pattern: Claude Code Is a Prefix Reuse Machine During our trace analysis, one phenomenon was so consistent it deserves its own section:\nClaude Code’s prompts are extremely prefix-heavy.\nPrefix reuse means that one part of the prompt prefix is seen in the previous prompts\u0026rsquo; prefix. Across all phases, the prompt reuse rate is extremely high: 92%. For ReAct-based subagent loops, it\u0026rsquo;s even higher. If we run prefix-length analysis in particular sections:\nTrace ID Total Tokens Shared Prefix % Notes #1-#6 47,177 0.22% Warm-up and initial phase #7-#45 546,104 92.06% Explore subagent phase #47-#72 528,286 93.23% Plan subagent phase #73-#92 827,411 97.83% Main agent execution phase What does this mean? Claude Code’s architecture practically optimizes itself for KV cache reusage, even without explicitly trying.\n3. What is prefix caching and why should I care? At the heart of Large Language Model inference lies the KV cache (key-value cache) — a mechanism that stores intermediate attention computation results for previously processed tokens. During autoregressive generation, each new token needs to attend to all previous tokens, requiring expensive matrix multiplications. The KV cache stores the key and value matrices computed for earlier tokens, so they don\u0026rsquo;t need to be recomputed with each new token.\nPrefix caching leverages this by recognizing that when multiple requests share the same prompt prefix (like system instructions or document context), their KV cache computations are identical and can be reused across requests.\nMajor LLM providers have turned this into significant cost savings:\nOpenAI's Prompt Caching handles prefix caching automatically — it detects common prefixes longer than 1,024 tokens and caches them transparently, offering a 90% discount on cached input tokens (e.g., GPT-5.2 drops from $1.75 to $0.175 per million cached tokens) Anthropic's cache hit pricing gives developers explicit control over which prompt blocks to cache using special cache_control markers, charging a slightly higher cache write cost (1.25x base price for 5-minute cache, 2x for 1-hour cache) but delivering the same 90% discount on cache reads (Claude Sonnet 4.5: $0.30 per million tokens for cache reads versus $3.00 for base input), allowing fine-grained optimization for complex multi-turn conversations or document-heavy workflows To put this in perspective with Claude Code\u0026rsquo;s 92% prefix reuse pattern: processing 2M input tokens (our consumption for the experiment) without caching would cost $6.00 (2M × $3/MTok), but with prefix caching, the cost drops to just $1.152 (1.84M cache hits × $0.30/MTok + 0.16M cache writes × $3.75/MTok) — a savings of $4.85 (81% reduction) over one simple task.\nOpen-source inference engines have also embraced this paradigm:\nvLLM's automatic prefix caching transparently caches shared prefixes using its PagedAttention mechanism SGLang's RadixAttention employs a radix tree data structure to efficiently match and reuse the longest common prefixes across requests LMCache takes distributed KV caching even further by pooling cache storage across multiple nodes to maximize reuse at scale Beyond cost savings, prefix cache hits dramatically reduce TTFT (time to first token) — since the model can skip recomputing the entire prefix and only process the unique suffix, latency for subsequent requests with shared context can drop by 5-10x, making conversational agents and document-grounded applications far more responsive.\n4. What We Learned from This Tiny Trace Even though the task was trivial, the trace reveals a lot about Claude Code as a system:\nThe main system prompt is huge\nIt contains: Complete git repository state and history + full tool specifications (18 tools for main agent) + finally, execution phase instructions The prompt alone is 20,000+ tokens without conversation history Claude Code is built around specialized subagents\nSubagents receive only role-specific context, reducing bloat Separation of context allows the main agent to only run on the summarized subagent responses Parallel execution is used to maximize exploration efficiency\nSubagents are spawned in parallel with different search goals under their own ReAct loop This separation allows clean context and focused subtasks, distributing context evenly Tool calls are also run in parallel for the same benefits \u0026ldquo;Warm-up\u0026rdquo; calls prime the cache before real work begins\nThey load tool specifications into cache, prime subagent system prompts, and establish stable prefix baselines These calls drastically accelerate subsequent subagent invocations Claude works well with KV cache reuse\nClaude reaches up to 92% overall prefix reuse, perfect for KV cache reuse optimization Results in a significant cost savings of $4.85 (81% reduction) over one simple task Interactive planning improves transparency\nGives users control over what changes will be made Creates a natural breakpoint prompting the user for approval Responses allow the system to create a more refined executable todo list, improving workflow 5. Beyond Prefix Caching: Can We Do Better? Recently, there are some interesting research papers that try to improve non-prefix caching efficiency, such as CacheBlend, where optimizations can be made even on non-prefix (substring) caching.\nIn our trace, we can see that the subagents have a tool list that is a subset of the main agent\u0026rsquo;s tool list, which means that the subagents can reuse the main agent\u0026rsquo;s tool list descriptions. This is a good example of how to improve non-prefix caching efficiency.\nAnother scenario in our trace is that if the same file was read multiple times, the file content can be cached and reused, even though the file content is not a prefix. This can be extremely helpful when the file content is large and the file is read multiple times.\n","permalink":"https://hanchenli.github.io/blogs/posts/claude_code/","summary":"\u003ch1 id=\"context-engineering--reuse-pattern-under-the-hood-of-claude-code\"\u003eContext Engineering \u0026amp; Reuse Pattern Under the Hood of Claude Code\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"Claude Code Architecture\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/kobe0938/blog/master/claude-code/assets/claude_code_diagram.png\"\u003e\u003c/p\u003e\n\u003cp\u003eOver the last few months, \u003ca href=\"https://www.claude.com/product/claude-code\"\u003eClaude Code\u003c/a\u003e has quietly become one of the most interesting \u0026amp; widely-adopted real-world agentic systems available to normal developers.\u003c/p\u003e\n\u003cp\u003eUnlike \u003cem\u003e\u003cstrong\u003ecloud-only agents\u003c/strong\u003e\u003c/em\u003e whose internals remain hidden behind API gateways like \u003ca href=\"https://www.perplexity.ai/api-platform\"\u003ePerplexity\u003c/a\u003e, \u003ca href=\"https://devin.ai/\"\u003eDevin\u003c/a\u003e, or \u003ca href=\"https://manus.im/\"\u003eManus\u003c/a\u003e, nor as fully \u003cem\u003e\u003cstrong\u003eopen source agents\u003c/strong\u003e\u003c/em\u003e like \u003ca href=\"https://github.com/SWE-agent/mini-swe-agent\"\u003eMini SWE Agent\u003c/a\u003e or \u003ca href=\"https://github.com/laude-institute/harbor/blob/main/src/harbor/agents/terminus_2/terminus_2.py\"\u003eTerminus 2\u003c/a\u003e where you can deploy locally with source code, Claude Code runs \u003cem\u003e\u003cstrong\u003epartially locally\u003c/strong\u003e\u003c/em\u003e — it has a open-sourced \u003ca href=\"https://github.com/anthropics/claude-code\"\u003eclient repo\u003c/a\u003e running on the local machine, which gives us a rare opportunity: to inject the traffic it sends and reverse engineering \u003cstrong\u003eto see every single LLM call\u003c/strong\u003e, every intermediate \u003cstrong\u003etool invocation\u003c/strong\u003e, every tiny decision the agent makes.\u003c/p\u003e","title":"Context Engineering \u0026 Reuse Pattern Under the Hood of Claude Code"},{"content":"Agents are EXPENSIVE. Claude Code takes 1 USD to handle a single issue in a mid-sized public repository when using API. In the same time, it charges 20 USD per month for a subscription license. Why do we still get to use them? Maybe the price war, maybe the crazy debts some companies upstream are carrying, maybe the implicit labeling you are carrying out for the providers.\nBut regardless of the reason behind the pricing, we want to use more these powerful agents. Current models and applications are already capable of handling many complex tasks with minimal human intervention. However, the efficiency of these agents has just rised to our attention. In this blog post, we will discuss why agents are efficiency nightmares, how we can make them (somewhat) better with KV cache management, and where we could be going for these tasks.\nPrerequisite: LLM inference basics. Suggested reading: LLM Inference; KV Cache Offloading\nWonderful Agents; But Draining Bank Account. Everyone said 2025 was the year of agents. With continuous improment in base model and emerging techniques like reinforcement learning, coding agents including Cursor, Claude Code have become much more powerful and automated compared with the start of the year. Quantitatively, the score on SWE-Bench has risen from 20% as in Aug 2024 to over 70% for frontier models with a simple agent scaffold.\nHowever, the cost of running these agents is still prohibitively high. We conducted a simple benchmark experiment running Claude Code with APIs to get a quantitative measure of the actual token cost.\nWe found that handling a single issue in a mid-sized public repository costs around 1 USD when using Claude Code via API. This is in stark contrast to the subscription license cost of 20 USD per month. There could be various reasons behind this pricing discrepancy, such as market dynamics, provider strategies, or the implicit value of the labeling work being done by the users. However, despite the high costs, the capabilities of these agents make them indispensable for many users. As proved by the usage-based pricing model adopted by Manus, many users are willing to pay for the advanced functionalities provided by these agents, even at a premium.\nHowever, as the adoption of these agents grows, the efficiency of their operation becomes increasingly important. This directly improves the Return-On-Investment (ROI) for users and makes these tools more accessible to a broader audience.\nThe Fundamental Inefficiency of Agents In order to understand why agents are so expensive to run, we need to look at how they operate fundamentally. We analyze trace from Claude Code and mini-swe-agent to give a brief overview. We used each agent to solve a coding task from SWE-bench_Verified dataset and recorded the message history sent.\nOverview Statistics We report some high-level statistics from the traces below:\nMethod Average Total Tokens Average Cost ($) Average Calls to LLM Prefix Cache Hit Rate Claude Code 15,000 1.0 45 92% Mini-SWE-Agent - - 30 88% Microscopic View We randomly select one task (#80) from the SWE-bench_Verified dataset. The problem setup is to fix an issue in the django/django repo from commit 2e0f04507b17362239ba49830d26fec504d46978.\nProblem statement:\n\u0026ldquo;JSONField are not properly displayed in admin when they are readonly.\nDescription: JSONField values are displayed as dict when readonly in the admin. For example, {\u0026quot;foo\u0026quot;: \u0026quot;bar\u0026quot;} would be displayed as {'foo': 'bar'}, which is not valid JSON.\nI believe the fix would be to add a special case in django.contrib.admin.utils.display_for_field to call the prepare_value of the JSONField (not calling json.dumps directly to take care of the InvalidJSONInput case).\u0026rdquo;\nAnd this is exactly the prompt that Claude Code received.\nSurprisingly, before any fancy reasoning, Claude Code ran a couple of \u0026ldquo;warm-up\u0026rdquo; steps (trace ID #2, #3, #4) before the actual task. Warm-up steps do nothing but input the prompt for:\nTool list (#2) Explore subagent (#3) Plan subagent (#4) Warm-up steps are used for caching purposes—later when those tools and subagents are called, the cache will be hit, resulting in faster response time. The summarization agent (#1) and new topic agent (#5) are used for summarizing the context and generating a new title for display—just as the ChatGPT sidebar works.\nThe main agent (#6) comes with a huge system prompt, including git history, status, tool list, etc. The 18 tools in the tool list not only have the ability to use normal tool calls like Bash, Grep, Read, WebFetch, AskUserQuestion, etc., but also the ability to invoke and delegate certain tasks to subagents like:\nExplore subagent (#7) Plan subagent (#46) These subagents will invoke tool calls from their own tool lists.\nImmediately after the main agent (#6), it invokes the Explore (also called file search agent) subagent (#7), which will invoke tool calls from its tool list to explore the codebase. It starts with a different system prompt where its main goal is to explore the codebase:\nYou are Claude Code, Anthropic\u0026rsquo;s official CLI for Claude. You are a file search specialist for Claude Code, Anthropic\u0026rsquo;s official CLI for Claude. You excel at thoroughly navigating and exploring codebases.\nInterestingly, the Explore subagent (#7) is not the only subagent that Claude Code can invoke. Instead, it invokes 3 Explore subagents in parallel to explore the codebase, each with a different goal:\nExplore JSONField implementation (lifespan: #7-#26) Explore admin display_for_field (lifespan: #8-#37) Explore readonly field rendering (lifespan: #9-#45) The context of the main agent (#6) is not carried to the subagents, which is beneficial for the subagents to have a fresh start. Each Explore subagent can invoke 1-3 tools in parallel, where the tools are from the tool list of the Explore subagent—a subset (10/18) of the main agent\u0026rsquo;s tool list.\nThe ReAct mechanism is used here: the Explore subagent will invoke a tool call, then based on the tool output, it will observe and invoke another tool call to explore the codebase further until it deems it has explored enough.\nFinally, after the slowest Explore subagent finishes its exploration at step #45, at step #46, the main agent appends the findings (summarizations) from all 3 Explore subagents to the context, and then invokes the Plan subagent (#47) to plan the fix.\nSimilar to the Explore Agent, the Plan Agent (#47) also has a different system prompt, where its main goal is to plan the fix:\nYou are Claude Code, Anthropic\u0026rsquo;s official CLI for Claude. You are a software architect and planning specialist for Claude Code. Your role is to explore the codebase and design implementation plans.\nThe Plan Agent did not carry all the context from the main agent nor the Explore subagents, which is beneficial for the Plan Agent to have a fresh start. Instead, it only contains the summarization of the Explore subagents\u0026rsquo; findings. The toolbox is a subset (10/18) of the main agent\u0026rsquo;s tool list. The goal for the Plan Agent is to design an implementation plan that:\nPlease design an implementation plan that:\nIdentifies the exact changes needed to display_for_field Considers whether we need to instantiate a form field from the model field or if there\u0026rsquo;s a better approach Identifies any edge cases or potential issues Recommends the best approach given Django\u0026rsquo;s architecture Similarly, the Plan Agent also follows the ReAct pattern and loops through tool calling from #47 to #72, where the context accumulates from 11,552 tokens to 38,819 tokens. After having a good plan (see details in #72), the Plan Agent will return to the main agent (#73) with the plan.\nThe main agent will then invoke a series of tool calls to:\nReview the plan (#73) Ask user for clarification (#74) Write the plan into a markdown file (#75) Finally, the main agent will exit the plan mode (#76) and enter the execute mode (#77) to execute the plan after interactively asking the user for plan approval (#76-#77).\nThe execution phase (#77-#91) still follows the ReAct pattern. The main agent will use the plan markdown file as a todo list:\nAdd json import to utils.py Add JSONField handling to display_for_field() Add tests to test_admin_utils.py Run the tests to verify After executing some tool calls to read or edit files, it will cross out the todo items in the plan markdown file. Once all the todo items are crossed out, the main agent will end with a conclusion message (#92).\nDuring this phase, there are some other subagents being invoked—e.g., the Extract Bash Command subagent (#93), where there\u0026rsquo;s only a one-shot prompt template for the subagent to extract the bash command in order to not run dangerous commands like rm without user confirmation by accident.\nAnd this is the whole diagram of the claude code trace:\nKey Observations We highlight three key observations from the trace analysis above that contribute to the inefficiency of agents:\nHigh number of calls: Agents make a large number of calls to the LLM server due to the need to repetitive get actions and report status. Each call incurs incremental prefill and may cause KV cache miss that requires recomputation. Appending Context: Agents often append new context to the existing conversation history, leading to longer input sequences and increased computational load for each call. Why is Current KV Cache Offloading Not Enough? From the table above, we can see that both agents have a high prefix cache hit rate (around 90%). Readers with background may wonder: 90+% Prefix Cache hit rate? Why not just run KV Cache Offloading and save 10x?\nHowever, there are three further considerations here:\nContention for Space: Due to the appending context behavior, the KV cache space is highly contended among different agent programs due to long context. Queueling Delay in Scheduling: While the current agent program is waiting on the tool, if the sched- uler allocates the GPU memory to other requests to maximize throughput, the KV cache for the current program will be removed from GPU memory. This incurs a queueing delay for each request when the program resumes after tool execution. Remaining Compute: As mentioned above, each call still requires prefill compute even with KV cache hit. With a high number of calls, the remaining compute becomes non-negligible. Some research works have demonstrated by mitigating the first two issues, KV cache offloading can bring significant speedup and cost reduction for serving LLMs. For example, Continuum proposes to reuse the Time-to-live (TTL) concept to preserve the KV cache for programs that are likely to be resumed soon to mitigate the first two problems.\nHowever, for agents, the remaining compute issue becomes more prominent due to the high number of calls made to the LLM.\nLooking Forward: Beyond KV Cache As we have discussed, while KV cache offloading can help alleviate some of the inefficiencies in agent operation, it is not a complete solution. To further improve the efficiency of agents, we need to look beyond just KV cache management. Some potential directions include:\nModel Optimization: Developing more efficient models with smaller footprints during long context. Adaptive Context Management: do not append unncessary context to the main loop Fundamentally memory bound. We need better algorithm and system co-design to make agents more efficient and accessible.\nConclusion We have discussed the inefficiencies of current agent systems and how KV cache sharing can help alleviate some of these issues. We explained\nDisclaimer: This blog post was created with help from Gemini, VSCode copilot. Views are solely those of the authors and do not reflect employer values.\n","permalink":"https://hanchenli.github.io/blogs/posts/kv_agent/","summary":"\u003cp\u003eAgents are EXPENSIVE. Claude Code takes 1 USD to handle a single issue in a mid-sized public repository when using API.\nIn the same time, it charges 20 USD per month for a subscription license.\nWhy do we still get to use them?\nMaybe the price war, maybe the crazy debts some companies upstream are carrying, maybe the implicit labeling you are carrying out for the providers.\u003c/p\u003e\n\u003cp\u003eBut regardless of the reason behind the pricing, we want to use more these powerful agents.\nCurrent models and applications are already capable of handling many complex tasks with minimal human intervention.\nHowever, the efficiency of these agents has just rised to our attention.\nIn this blog post, we will discuss why agents are efficiency nightmares, how we can make them (somewhat) better with KV cache management,\nand where we could be going for these tasks.\u003c/p\u003e","title":"Why Agents are Efficiency Nightmares and How to Fix them?"}]